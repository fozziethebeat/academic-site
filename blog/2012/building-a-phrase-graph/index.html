<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>

  FozzieTheBeat


  | Building a Phrase Graph

</title>
<meta name="description" content="A simple blog tracking my journey back into Open Source.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css" integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet" href="https://raw.githubusercontent.com/jwarby/pygments-css/master/github.css" />

<!-- Styles -->

<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22></text></svg>">

<link rel="stylesheet" href="/assets/css/main.css">
<link rel="canonical" href="/blog/2012/building-a-phrase-graph/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<script src="/assets/js/dark_mode.js"></script>






    
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  </head>

  <body class="fixed-top-nav ">

    <!-- Header -->

    <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="https://fozziethebeat.com/">
       FozzieTheBeat
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          

          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


    <!-- Content -->

    <div class="container mt-5">
      

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Building a Phrase Graph</h1>
    <p class="post-meta">August 12, 2012</p>
  </header>

  <article class="post-content">
    <p>Research papers. I hate them sometimes. They present a great idea, talk about
how it can be used and applied, and then give only the barest description of
how to actually build and implement the idea, often with no pointers or links
to what they built. My current frustration is with building a <em>Phrase Graph</em>.
The idea behind phrase graphs are pretty simple, they encode a large set of
sentences with a minimal automata.</p>

<p>Here’s a simple example. Say you have the following two sentences:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#archery by the Republic of Korea and the guy is legally blind.
#archery by the Republic of Korea and the guy who is legally blind.
#archery by the Republic of Korea in archery by a guy who is legally blind.
</code></pre></div></div>

<p>There’s quite a lot of overlap at the start of the sentence and at the end of the sentence. So a good phrase graph would look something like this:</p>

<p><img src="/assets/img/2012/phrase-graph-example.svg" alt="Example Phrase Graph" /></p>

<p>So you can see that the nodes in the graph represent words found in the
sentences observed and if you weight the nodes based on how often they are
traversed, you can start to detect which phrases are used most frequently. But
how does one do this? And how does one do this efficiently? This is where
research papers make me mad. They fail to point out the simplest algorithms for
building these awesome ideas. To complement these research ideas, this post’ll
give a little more detail on what these phrase graphs are, an easy way to build
them using existing libraries, and code to write your own custom phrase graph!</p>

<h3 id="badly-described-methods-for-building-a-phrase-graph">Badly described methods for building a phrase graph</h3>

<p>The first paper I read for building phrase graphs, titled <a href="http://www.jeffreynichols.com/papers/summary-iui2012.pdf">Summarizing Sporting
events using
Twitter</a>, gives this
highly detailed algorithm description:</p>

<blockquote>
  <p>The phrase graph consists of a node for each word appearing in any status
update, and an edge between each set of two words that are used adjacently in
any status update</p>
</blockquote>

<p>Seems easy to implement, no? Here’s a more detailed algorithm, found in <a href="http://www.cs.uccs.edu/~jkalita/papers/2010/SharifiBeauxSocialcom2010.pdf">Experiments in Microblog Summarization</a>:</p>

<blockquote>
  <p>To construct the left-hand side, the algorithm starts with the root node. It
reduces the set of input sentences to the set of sentences that contain the
current node’s phrase. The current node and the root node are initially the
same. Since every input sentence is guaranteed to contain the root phrase,
our list of sentences does not change initially. Subsequently, the algorithm
isolates the set of words that occur immediately before the current node’s
phrase. From this set, duplicate words are combined and assigned a count that
represents how many instances of those words are detected. For each of these
unique words, the algorithm adds them to the graph as nodes with their
associated counts to the left of the current node.</p>
</blockquote>

<p>This gives a lot more detail on what the phrase graph contains, and an easy
enough algorithm, but it’s not exactly a fast algorithm, especially if you want
to do this using 10 million tweets about the Olympics. Both descriptions leave
out a key detail: these phrase graphs are really just <a href="https://en.wikipedia.org/wiki/Trie#Compressing_tries">Compressed
Tries</a>.</p>

<h3 id="tries-and-their-compressed-cousins">Tries and their compressed cousins</h3>

<p><img src="/assets/img/2012/trie-example.svg" alt="Trie Example" /></p>

<p>Tries are one of the simplest data structures, and one of the most powerful
when processing natural languages. Given a set of words or sentences, a Trie is
essentially a standard tree where the leaves represent observed words or
sentences. The power of it is that each internal node in the Trie represents
overlapping sequences. So if you want to build a Trie for an <a href="https://www.brics.dk/automaton/">English
Dictionary</a>, the root node would be a blank
character, which then points to a node for each letter of the alphabet. From
the “a” child, you would then have access to all words starting with “a”, and
the further down the Trie you go, you get longer prefixes of words.</p>

<p>Now a Phrase Graph is essentially a Trie which condenses not only shared
prefixes, but also any shared subsequence, be they in the middle, or the end.
Formally, they are directed acyclic graphs, and if they are treated as a lookup
structure, ala a dictionary, they are called Minimal Acyclic Finite-State
Automata. And there’s plenty of fast and simple ways to build these things. The
easiest places to start reading about these is <a href="https://aclanthology.org/J00-1002.pdf">Incremental Construction of
Minimal Acyclic Finite State Automata</a>.
The <a href="https://www.brics.dk/automaton/">Brics Automaton</a> package also provides a
really good implantation for these that works</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nn">dk.brics.automaton.BasicAutomata</span>
<span class="k">val</span> <span class="nv">automata</span> <span class="k">=</span> <span class="nv">BasicAutomata</span><span class="o">.</span><span class="py">makeStringUnion</span><span class="o">(</span>
    <span class="s">"#archery by the Republic of Korea and the guy is legally blind"</span><span class="o">,</span>
    <span class="s">"#archery by the Republic of Korea in archery by a guy who is legally blind"</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">automata</span><span class="o">.</span><span class="py">toDot</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><img src="/assets/img/2012/brics-phrase-graph-example.svg" alt="A Brics Phrase Graph" /></p>

<p>NOTE: You may want to open this in a new tab to zoom in as every letter has it’s own state.</p>

<h3 id="rolling-your-own-automata-builder">Rolling your own automata builder</h3>

<p>Using Brics works really well if you just want to check whether or not a
sentence matches one seen in a corpus. However, it doesn’t easily let you check
how often particular sub-phrases are used within the corpus. For that kinda
power, you’ll have to craft your own implemenation. And now it’s time to share
the very code to do this!</p>

<h4 id="nodes-in-the-graph-thats-where">Nodes in the graph, that’s where.</h4>

<p>Where does one start? First, you need a node data structure, with some very
carefully crafted functions to determine equality (which indidentally, the
research papers <em>don’t</em> point out).</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
</pre></td><td class="code"><pre><span class="cm">/**
 * A simple node structure that records a label, a weight, and a mapping from this node to other nodes using labeled arcs.  This
 * implementation overrides {@link hashCode} and {@link equals} such that only nodes with the same label and which point to the same exact
 * children (i.e.  same objects, not equivalent objects), are considered equal.
 **/</span>
<span class="k">class</span> <span class="nc">PhraseNode</span><span class="o">(</span><span class="k">val</span> <span class="nv">label</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>

    <span class="cm">/**
     * The internal weight for this {@link PhraseNode}.
     */</span>
    <span class="k">var</span> <span class="n">inCount</span> <span class="k">=</span> <span class="mf">0d</span>

    <span class="cm">/**
     * A mapping from this {@link PhraseNode} to children {@link PhraseNode}s using labeled arcs.
     */</span>
    <span class="k">var</span> <span class="n">linkMap</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">PhraseNode</span><span class="o">]()</span>

    <span class="cm">/**
     * A record of the last {@link PhraseNode} added as a child to this {@link PhraseNode}.
     */</span>
    <span class="k">var</span> <span class="n">lastAdded</span><span class="k">:</span><span class="kt">PhraseNode</span> <span class="o">=</span> <span class="kc">null</span>

    <span class="cm">/**
     * Returns the {@link PhraseNode} connected to {@code this} {@link PhraseNode} via the arc {@code term}.  If no such node exists, a new
     * {@link PhraseNode} is created and returned.
     */</span>
    <span class="k">def</span> <span class="nf">neighbor</span><span class="o">(</span><span class="n">term</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
        <span class="nv">linkMap</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">term</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">node</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">node</span>
            <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="n">lastAdded</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PhraseNode</span><span class="o">(</span><span class="n">term</span><span class="o">)</span>
                           <span class="n">linkMap</span> <span class="o">+=</span> <span class="o">(</span><span class="n">term</span> <span class="o">-&gt;</span> <span class="n">lastAdded</span><span class="o">)</span>
                           <span class="n">lastAdded</span>
                         <span class="o">}</span>
        <span class="o">}</span>

    <span class="cm">/**
     * Adds {@code delta} to the {@code inCount} and returns a pointer to {@code this} {@link PhraseNode}.
     */</span>
    <span class="k">def</span> <span class="nf">addCount</span><span class="o">(</span><span class="n">delta</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
        <span class="n">inCount</span> <span class="o">+=</span> <span class="n">delta</span>
        <span class="k">this</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Returns a hashcode based on java's internal hash code method for every object which uniquely identifies every object.
     */</span>
    <span class="k">def</span> <span class="nf">pointerHashCode</span> <span class="k">=</span> <span class="nv">super</span><span class="o">.</span><span class="py">hashCode</span>

    <span class="cm">/**
     * Override {@code hashCode} to use three factors:
     * &lt;ol&gt;
     *  &lt;li&gt;The hash code for {@code label}&lt;/li&gt;
     *  &lt;li&gt;The hash code for {@code label} of each child node&lt;/li&gt;
     *  &lt;li&gt;The hash code for {@code pointer} of each child node&lt;/li&gt;
     * &lt;/ol&gt;
     * This ensures that nodes only have the same hash code if they have the same label, same number of children, same links to those
     * children, and point to the very same children.  This is a cheap and fast way to ensure that we don't accidently consider two nodes
     * with the same link labels aren't equivalent.
     */</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">hashCode</span> <span class="k">=</span>
        <span class="nv">linkMap</span><span class="o">.</span><span class="py">map</span><span class="o">{</span> <span class="nf">case</span><span class="o">(</span><span class="n">childLabel</span><span class="o">,</span> <span class="n">child</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="nv">childLabel</span><span class="o">.</span><span class="py">hashCode</span> <span class="o">^</span> <span class="nv">child</span><span class="o">.</span><span class="py">pointerHashCode</span>
        <span class="o">}.</span><span class="py">foldLeft</span><span class="o">(</span><span class="nv">label</span><span class="o">.</span><span class="py">hashCode</span><span class="o">)(</span><span class="k">_</span><span class="o">^</span><span class="k">_</span><span class="o">)</span>

    <span class="cm">/**
     * Override {@code equals} to use the same three factors as {@cod hachCode}:K
     * &lt;ol&gt;
     *  &lt;li&gt;The {@code label}&lt;/li&gt;
     *  &lt;li&gt;The {@code label} of each child node&lt;/li&gt;
     *  &lt;li&gt;The {@code pointer} of each child node&lt;/li&gt;
     * &lt;/ol&gt;
     * 
     * This ensures that nodes only equal when they have the same distinguishing meta data and point to the same children.
     */</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">equals</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span>
        <span class="n">that</span> <span class="k">match</span> <span class="o">{</span>
            <span class="k">case</span> <span class="n">other</span><span class="k">:</span> <span class="kt">PhraseNode</span> <span class="o">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="py">hashCode</span> <span class="o">!=</span> <span class="nv">other</span><span class="o">.</span><span class="py">hashCode</span><span class="o">)</span> <span class="kc">false</span>
                                      <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="py">label</span> <span class="o">!=</span> <span class="nv">other</span><span class="o">.</span><span class="py">label</span><span class="o">)</span> <span class="kc">false</span>
                                      <span class="k">else</span> <span class="nf">compareLinkMaps</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="py">linkMap</span><span class="o">,</span> <span class="nv">other</span><span class="o">.</span><span class="py">linkMap</span><span class="o">)</span>
            <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
        <span class="o">}</span>

    <span class="cm">/**
     * Returns true if the two maps have the same size, same keys, and the key in each map points to the same object.  We use this instead
     * of simply calling equals between the two maps because we want to check node equality using just the pointer hash code, which prevents
     * walking down the entire graph structure from each node.
     */</span>
    <span class="k">def</span> <span class="nf">compareLinkMaps</span><span class="o">(</span><span class="n">lmap1</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">PhraseNode</span><span class="o">],</span> <span class="n">lmap2</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">PhraseNode</span><span class="o">])</span> <span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
        <span class="nf">if</span> <span class="o">(</span><span class="nv">lmap1</span><span class="o">.</span><span class="py">size</span> <span class="o">!=</span> <span class="nv">lmap2</span><span class="o">.</span><span class="py">size</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="nf">for</span> <span class="o">(</span> <span class="o">(</span><span class="n">key1</span><span class="o">,</span> <span class="n">entry1</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">lmap1</span> <span class="o">)</span> <span class="o">{</span>
            <span class="k">val</span> <span class="nv">matched</span> <span class="k">=</span> <span class="nv">lmap2</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">key1</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
                <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">entry2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">entry2</span><span class="o">.</span><span class="py">pointerHashCode</span> <span class="o">==</span> <span class="nv">entry1</span><span class="o">.</span><span class="py">pointerHashCode</span>
                <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="kc">false</span>
            <span class="o">}</span>
            <span class="nf">if</span> <span class="o">(!</span><span class="n">matched</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span>
        <span class="o">}</span>
        <span class="kc">true</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This PhraseNode has three fairly simple data members, a label that records
which word the node represents, the weight of the node, and a map from this
node to it’s children based on their labels. The tricky part of this node is
how you determine equality. Two nodes can be equal in two different senses: 1)
they are the exact same data structure in memory, and so their memory locations
are the same or 2) they have the same label and point to the same exact
children in memory. Checking the first type of equality is easy, you can
compare the hash code of their addresses using the default hashCode method java
provides for every object. Checking the second form of equality is more
challenging to do efficiently. The naive way would be to recursively check that
all children eventually point to sub-graphs with the same structure. However,
checking the hash code of the pointers of each children is much faster and
accomplishes the same goal. Hence, this is why we override hashCode and equals
with such complicated code.</p>

<h4 id="linking-together-those-phrase-nodes">Linking together those Phrase Nodes</h4>

<p>The algorithm for linking together PhraseNodes such that they form a minimal
transducer relies on a few interesting tricks and beautiful recursion. The
first trick we need is lexicographically sorted input. By sorting the input,
you’re maximizing the size of matching prefixes between any neighboring words
you want to put in the transducer. So let’s look at how we do that adding in
sorted order.</p>

<p>Before we get there though, let’s flesh sketch out a CondensedTrie data
structure. It’s pretty simple. It starts off with just having a single
PhraseNode element, the root.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="cm">/**
 * The {@link CondensedTrie} represents a single phrase graph centered around a single key phrase.  Lists of tokens, representing sentences,
 * can be added to the {@link CondensedTrie} to create a minimal finite state automata which counts the number of times sequences of tokens
 * appear.  Lists must be added in fully sorted order, otherwise the behavior is undefined.  Once the {@link CondensedTrie} has been
 * completed, a sequence of tokens can be used to walk through the {@link CondensedTrie} and count the weight of that particular sequence.
 **/</span>
<span class="k">class</span> <span class="nc">CondensedTrie</span><span class="o">()</span> <span class="o">{</span>

    <span class="cm">/**
     * The root node in the {@link CondensedTrie}.  This always has an emtpy label.
     */</span>
    <span class="k">val</span> <span class="nv">root</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PhraseNode</span><span class="o">(</span><span class="s">""</span><span class="o">)</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Now comes adding entries. Since we want a clean and easy to use interface,
we’ll be defensive and assume the elements aren’t sorted, but they are already
tokenized, so each element in the given list is a sequence of tokens. How you
sort thoes beasts is a homework assignment.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="cm">/**
 * Trains the {@link CondensedTrie} on a list of token sequences.  This list does not have to be sorted and will instead be sorted
 * before any sentences are added.
 */</span>
<span class="k">def</span> <span class="nf">train</span><span class="o">(</span><span class="n">tokenizedSentences</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]])</span> <span class="o">{</span>
    <span class="nf">for</span> <span class="o">(</span> <span class="n">tokenizedSentence</span> <span class="k">&lt;-</span> <span class="nv">tokenizedSentences</span><span class="o">.</span><span class="py">sortWith</span><span class="o">(</span><span class="nv">Util</span><span class="o">.</span><span class="py">tokenListComparator</span><span class="o">)</span> <span class="o">)</span>
        <span class="nf">add</span><span class="o">(</span><span class="n">tokenizedSentence</span><span class="o">)</span>
    <span class="nf">if</span> <span class="o">(</span><span class="nv">root</span><span class="o">.</span><span class="py">linkMap</span><span class="o">.</span><span class="py">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
        <span class="nf">replaceOrRegister</span><span class="o">(</span><span class="n">root</span><span class="o">)</span>
<span class="o">}</span>

<span class="cm">/**
 * Adds the list of tokens to this {@link CondensedTrie}.
 */</span>
<span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">tweet</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
    <span class="nf">val</span> <span class="o">(</span><span class="n">lastSharedNode</span><span class="o">,</span> <span class="n">remainingSuffix</span><span class="o">)</span> <span class="k">=</span> <span class="nf">computeDeepestCommonNodeAndSuffix</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">tweet</span><span class="o">)</span>
    <span class="nf">if</span> <span class="o">(</span><span class="nv">lastSharedNode</span><span class="o">.</span><span class="py">linkMap</span><span class="o">.</span><span class="py">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
        <span class="nf">replaceOrRegister</span><span class="o">(</span><span class="n">lastSharedNode</span><span class="o">)</span>
    <span class="nf">addSuffix</span><span class="o">(</span><span class="n">lastSharedNode</span><span class="o">,</span> <span class="n">remainingSuffix</span><span class="o">)</span>
<span class="o">}</span>

<span class="cm">/**
 * Returns the deepest {@link PhraseNode} in the {@link CondensedTrie} matching the tokens in {@code tweet}.  When a {@link PhraseNode}
 * no longer has an arc matching the first element in {@code tweet}, this returns that {@link PhraseNode} and the remaining tokens in
 * {@code tweet} that cold not be matched.
 */</span>
<span class="k">def</span> <span class="nf">computeDeepestCommonNodeAndSuffix</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">PhraseNode</span><span class="o">,</span> <span class="n">tweet</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">:</span> <span class="o">(</span><span class="kt">PhraseNode</span><span class="o">,</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span>
    <span class="n">tweet</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">head</span><span class="o">::</span><span class="n">tail</span> <span class="k">=&gt;</span> <span class="nv">node</span><span class="o">.</span><span class="py">linkMap</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">head</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">child</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
                <span class="nv">child</span><span class="o">.</span><span class="py">addCount</span><span class="o">()</span>
                <span class="nf">computeDeepestCommonNodeAndSuffix</span><span class="o">(</span><span class="n">child</span><span class="o">,</span> <span class="n">tail</span><span class="o">)</span>
            <span class="o">}</span>
            <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">tweet</span><span class="o">)</span>
        <span class="o">}</span>
        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">tweet</span><span class="o">)</span>
    <span class="o">}</span>

<span class="cm">/**
 * Adds all tokens in {@code tweet} as a branch stemming from {@code node}
 */</span>
<span class="k">def</span> <span class="nf">addSuffix</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">PhraseNode</span><span class="o">,</span> <span class="n">tweet</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
    <span class="nv">tweet</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="n">node</span><span class="o">)(</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">n</span><span class="o">.</span><span class="py">neighbor</span><span class="o">(</span><span class="n">t</span><span class="o">).</span><span class="py">addCount</span><span class="o">()</span> <span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>These methods are mostly simple. addSuffix starts adding links to nodes
starting from some initial point, note that nodes will automatically create a
new node for a word if one doesn’t already exist.
computeDeepestCommonNodeAndSuffix walks down the Trie starting at the root
consuming each token that has a node and returns the deepest node reachable,
i.e. finds the node with the longest common prefix with a given sequence of
tokens. Finally adding a single tweet depends on getting the prefix, doing some
magic called replaceOrRegister and then adding the suffix to the last node in
the longest prefix. So, only question left, what is this registry business?</p>

<p>The registry keeps track of all nodes in the graph after they’ve been
validated. And what does validation entail? It involves checking wether or not
an existing node already exists in the registry. If one does, you simply
replace that duplicate node with the one in the registry. If no such node
exists, in goes the node. And this is exactly what replaceOrRegister does. To
do this efficiently and correctly, we call replaceOrRegister on the last node
in our comment prefix and walk all the way down along the most recently added
path, i.e. the added by the last element we added, and then zip up any matching
nodes which correspond to matching suffixes. By starting at the bottom, we
match together end points which have no children and merge them.</p>

<p>Take our archery example above, all three sentences end with “is legally
blind.” After we add the first sentence, there would be a node for each token
in the order of the sentence. When we add the second sentence and walk down to
the end, we see that “blind.” has a duplicate, which we can merge. Taking one
step backwards, we’ll see that “legally” also has an exact match, where two
nodes with the same label point to the same exact node, the node we just
merged. And then thanks to recursion, we keep zipping things along until we get
to “who”, which has no exact match, and we can stop zipping. Walking through an
example like this should make the code below a little clearer.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="cm">/**
 * Recursively walks down the chain of last nodes added starting at {@code node} and then checks if the last child of that node are in the
 * registry.  If an equivalent {@link PhraseNode} matching the last child is in the registry, this replaces the last child with the
 * registry node.  If no matching {@link PhraseNode} exists in the registry, then the last child is added to the registry.
 **/</span>
<span class="k">def</span> <span class="nf">replaceOrRegister</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">PhraseNode</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Recursively replace or register the last added child of the current node.</span>
    <span class="k">val</span> <span class="nv">child</span> <span class="k">=</span> <span class="nv">node</span><span class="o">.</span><span class="py">lastAdded</span>
    <span class="nf">if</span> <span class="o">(</span><span class="nv">child</span><span class="o">.</span><span class="py">linkMap</span><span class="o">.</span><span class="py">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
        <span class="nf">replaceOrRegister</span><span class="o">(</span><span class="n">child</span><span class="o">)</span>

    <span class="c1">// Get the possible matches for the last child.</span>
    <span class="k">val</span> <span class="nv">candidateChildren</span> <span class="k">=</span> <span class="nv">register</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="nv">child</span><span class="o">.</span><span class="py">label</span><span class="o">)</span>
    <span class="c1">// Select only the registry node which has an exact match to the last</span>
    <span class="c1">// child.  We can also replace this equivalence check for a subsumption</span>
    <span class="c1">// check later on to condence the trie even more while breaking the</span>
    <span class="c1">// automata contract.</span>
    <span class="nv">candidateChildren</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="nf">matchMethod</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">child</span><span class="o">))</span> <span class="k">match</span> <span class="o">{</span>
        <span class="c1">// If such a child exists, merge the counts of the last child to the</span>
        <span class="c1">// existing child and link the parent to the existing child.  This</span>
        <span class="c1">// is just a convenient way to match a list, which is what gets</span>
        <span class="c1">// returned by filter</span>
        <span class="k">case</span> <span class="n">existingChild</span> <span class="o">::</span> <span class="n">tail</span> <span class="k">=&gt;</span>
            <span class="nv">existingChild</span><span class="o">.</span><span class="py">addCount</span><span class="o">(</span><span class="nv">child</span><span class="o">.</span><span class="py">inCount</span><span class="o">)</span>
            <span class="c1">// Make sure to update the most recently added node with the</span>
            <span class="c1">// registry version!</span>
            <span class="nv">node</span><span class="o">.</span><span class="py">lastAdded</span> <span class="k">=</span> <span class="n">existingChild</span>
            <span class="nv">node</span><span class="o">.</span><span class="py">linkMap</span> <span class="o">+=</span> <span class="o">(</span><span class="nv">child</span><span class="o">.</span><span class="py">label</span> <span class="o">-&gt;</span> <span class="n">existingChild</span><span class="o">)</span>
        <span class="c1">// If no chld exists, put the last child in the registery.</span>
        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nv">register</span><span class="o">.</span><span class="py">put</span><span class="o">(</span><span class="nv">child</span><span class="o">.</span><span class="py">label</span><span class="o">,</span> <span class="n">child</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>And Voila, we now have all the code needed to make a phrase graph!</p>

<p><img src="/assets/img/2012/example.exact.phrase-graph.svg" alt="Exact Phrase Graph" /></p>

<h3 id="tweaking-the-automata-to-condense-more-phrases">Tweaking the automata to condense more phrases</h3>

<p>BUT! Suppose you want something more minimal? Suppose you think it’s kinda
funny that interjection of “who” prevents “guy SOMETHING OR NOTHING is” from
being a phrase. Or you try adding in the sentence</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#archery ZOIDBERG by the Republic of Korea and the guy who is legally blind.
</code></pre></div></div>

<p>and notice how it creates an entirely new branch for “the Republic of Korea”
starting at “ZOIDBERG”, thus making the number of times you think you’ve seen
that phrase dependent on the previous tokens. Can we fix this? YES! All we have
to do is relax our definition of finding a matching element in the registry to
finding a node whose outgoing links are a superset of the most recently added
children.</p>

<p>And since Scala is awesome, we can do this with minimal effort.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">CondensedTrie</span><span class="o">(</span><span class="n">useSubsumingMatches</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span> <span class="o">{</span>
    <span class="cm">/**
     * The filtering method for determining which candidate node from the register will replace existing children nodes during the
     * compaction phase.
     */</span>
    <span class="k">val</span> <span class="nv">matchMethod</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">useSubsumingMatches</span><span class="o">)</span> <span class="n">subsumeMatch</span> <span class="k">_</span>

    <span class="cm">/**
     * Returns true if {@code child} and {@code candidate} are exact matches.
     */</span>
    <span class="k">def</span> <span class="nf">exactMatch</span><span class="o">(</span><span class="n">candidate</span><span class="k">:</span> <span class="kt">PhraseNode</span><span class="o">,</span> <span class="n">child</span><span class="k">:</span> <span class="kt">PhraseNode</span><span class="o">)</span> <span class="k">=</span>
        <span class="n">candidate</span> <span class="o">==</span> <span class="n">child</span>

    <span class="cm">/**
     * Returns true if {@code child} and {@code candidate} have the same label and the links from {@code child} are a subset of the links
     * from {@code candidate}.
     */</span>
    <span class="k">def</span> <span class="nf">subsumeMatch</span><span class="o">(</span><span class="n">candidate</span><span class="k">:</span> <span class="kt">PhraseNode</span><span class="o">,</span> <span class="n">child</span><span class="k">:</span> <span class="kt">PhraseNode</span><span class="o">)</span> <span class="k">=</span>
        <span class="nf">if</span> <span class="o">(</span><span class="nv">candidate</span><span class="o">.</span><span class="py">label</span> <span class="o">!=</span> <span class="nv">child</span><span class="o">.</span><span class="py">label</span><span class="o">)</span>
            <span class="kc">false</span>
        <span class="k">else</span>
            <span class="nv">child</span><span class="o">.</span><span class="py">linkMap</span><span class="o">.</span><span class="py">map</span><span class="o">{</span> <span class="nf">case</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">subchild</span><span class="o">)</span> <span class="k">=&gt;</span>
                <span class="nv">candidate</span><span class="o">.</span><span class="py">linkMap</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
                    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">otherSubchild</span><span class="o">)</span> <span class="k">if</span> <span class="nv">otherSubchild</span><span class="o">.</span><span class="py">pointerHashCode</span> <span class="o">==</span> <span class="nv">subchild</span><span class="o">.</span><span class="py">pointerHashCode</span> <span class="k">=&gt;</span> <span class="kc">true</span>
                    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
                <span class="o">}</span>
            <span class="o">}.</span><span class="py">foldLeft</span><span class="o">(</span><span class="kc">true</span><span class="o">)(</span><span class="k">_</span><span class="o">&amp;&amp;</span><span class="k">_</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>All we had to do was update the contractor to take in a boolean, then create a new data member that links to one of two comparison functions for pairs of nodes: 1) an exact matching function, which we would use for a true compressed trie and 2) a subset matching function, to get our even more compressed sorta-trie. If we swap in subsumeMatch, we now get this phrase graph:</p>

<p>Let’s see how the two versions handle this as input:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Republic of Korea in archery by a guy who is legally blind
#archery by the Republic of Korea and by the guy is legally blind
#archery by the Republic of Korea and the guy is legally blind
#archery by the Republic of Korea in archery by a guy who is legally blind
#archery zoidberg by the Republic of Korea and by the guy is legally blind
#archery zoidberg by the Republic of Korea in archery by a guy who is legally blin
</code></pre></div></div>

<p>Using exact Matching: Using Exact Matching:</p>

<p><img src="/assets/img/2012/test.exact.svg" alt="Exact Matching" /></p>

<p>Using link subset Matching:</p>

<p><img src="/assets/img/2012/test.subsume.svg" alt="Subsume Matching" /></p>

<p>Finally! This second version is precisely the data structure those three
original papers were describing.</p>

  </article>

  

</div>

    </div>

    <!-- Footer -->

    
<footer class="fixed-bottom">
  <div class="container mt-0">
    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
      <img alt="Creative Commons License"
           style="border-width:0"
           src="https://i.creativecommons.org/l/by/4.0/88x31.png" />
    </a>
    This
    work is licensed under a
    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
      Creative Commons Attribution 4.0 International License
    </a>.

    <br />

    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with the <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>.

  </div>
</footer>



  </body>

  <!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>

  
<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>


  


<!-- Medium Zoom JS -->
<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/assets/js/zoom.js"></script>


<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
