<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>

  FozzieTheBeat


  | Morphological Analysis Made Easy With Scala

</title>
<meta name="description" content="A simple blog tracking my journey back into Open Source.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css" integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet" href="https://raw.githubusercontent.com/jwarby/pygments-css/master/github.css" />

<!-- Styles -->

<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22></text></svg>">

<link rel="stylesheet" href="/assets/css/main.css">
<link rel="canonical" href="/blog/2012/morphological-analysis-made-easy-with-scala/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<script src="/assets/js/dark_mode.js"></script>






    
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  </head>

  <body class="fixed-top-nav ">

    <!-- Header -->

    <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="https://fozziethebeat.com/">
       FozzieTheBeat
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          

          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


    <!-- Content -->

    <div class="container mt-5">
      

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Morphological Analysis Made Easy With Scala</h1>
    <p class="post-meta">February 29, 2012</p>
  </header>

  <article class="post-content">
    <p>Ever since I got involved with distributional semantics, i’ve been perplexed about how to handle morphed words, which happens to be just about every noun and verb in English. What is a morphed word in English you ask? It’s pretty much any word that’s been changed to reflect things like past tense, plurality, ownership, and all those things. They’re conjugated verbs and more! But they always pose a massive problem in distributional semantics.</p>

<p>Think about it for a second, what’s the big difference between “cat” and
“cats”? Not too much, the second is simply saying there are multiple
occurrences of a “cat”. But what do people typically do for distributional
semantics? One of two bad options: leave the two words as separate things and
thus split the information gained about “cat” across two words or stem every
word and throw away something important like the multitude of “cat”. Both seem
totally wrong and unsatisfactory.</p>

<p>So on and off I’ve searched for a good tool to do morphological analysis for
English. Ideally, the analyzer could recognize the word “cats” and split into
two things: cat and that way you can retain all your information about a cat
and still know that there were a multitude of them when you see “cats”. And for
verbs? You should see the same thing, ran could then become something like run
and <code class="language-plaintext highlighter-rouge">&lt;past&gt;</code> so that again, you still know everything about running and that it
happened in the past. But until today, I’ve never found a tool that does this
both quickly and easily in a usable language.</p>

<p>That all changes today. Today I found the
<a href="wiki.apertium.org/wiki/Lttoolbox-java">Lltool-box</a> for Java. It creates a
large finite state machine for recognizing morphed words and figuring out the
root word, i.e. “run” in “ran” and “cat” in “cats”, and how the word was
morphed, i.e. “run” for “ran” and “cat” for “cats”. All you have to do is get a
listing of how words are morphed, load it up until the Lttoolbox-java system
and analyze away your sentences.</p>

<p>So let’s take a spin on how to do this. First, you read the wiki instructions
for Lttoolbox-java, download it, and compile it. Compiling is easy:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mvn deploy <span class="nt">-DskipTests</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">-DskipTests</code> part seems needed since their unit tests don’t pass. But
after that, you can start using the code in your favorite jvm based language.
my personal fave is Scala, so let’s run with that. So what next? Now you create
a <a href="https://en.wikipedia.org/wiki/Finite-state_transducer">Finite State
Transducer</a> using a
dictionary file and tell it to analyze words:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create the Finite State Transducer processor.</span>
<span class="k">val</span> <span class="nv">fstp</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">FSTProcessor</span><span class="o">()</span>

<span class="c1">// Load the finite state transducer with the compiled dictionary file.  </span>
<span class="nv">fstp</span><span class="o">.</span><span class="py">load</span><span class="o">(</span><span class="nf">openInFileStream</span><span class="o">(</span><span class="nf">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)))</span>

<span class="c1">// Setup the trandsducer to do morphological analysis and make sure it's valid.</span>
<span class="nv">fstp</span><span class="o">.</span><span class="py">initAnalysis</span>
</code></pre></div></div>

<p>Now that you have a transducer ready to analyze words, you just feed it stuff
like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">in</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringReader</span><span class="o">(</span><span class="s">"cats, dogs and blubber all running quickly!"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">out</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringWriter</span><span class="o">()</span>
<span class="c1">// Do the analysis.</span>
<span class="nv">fstp</span><span class="o">.</span><span class="py">analysis</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">)</span>
</code></pre></div></div>

<p>You gotta create a reader and writer for their transducer interface. It’s
funky, but it still leaves you with a pretty flexible interface. So now what?
What does the output look like? If you feed it “cats, dogs and blubber all
running quickly!”, the output is pretty ugly at first:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>^cats/cat&lt;n&gt;&lt;pl&gt;$^,/,&lt;cm&gt;$
^dogs/dog&lt;n&gt;&lt;pl&gt;$
^and/and&lt;cnjcoo&gt;$
^blubber/*blubber$
^all/all&lt;adj&gt;/all&lt;adv&gt;/all&lt;predet&gt;&lt;sp&gt;/all&lt;det&gt;&lt;qnt&gt;&lt;pl&gt;/all&lt;det&gt;&lt;qnt&gt;&lt;sp&gt;/all&lt;prn&gt;&lt;qnt&gt;&lt;mf&gt;&lt;sp&gt;$
^running/run&lt;vblex&gt;&lt;ger&gt;/run&lt;vblex&gt;&lt;pprs&gt;/run&lt;vblex&gt;&lt;subs&gt;/running&lt;adj&gt;/running&lt;n&gt;&lt;sg&gt;$
^quickly/quickly&lt;adv&gt;$
</code></pre></div></div>

<p>Beastly no? So i figure that it’s best to write some regular expressions to
handle all of this. You’ll need a couple: one to split up words, one to match
analysed words, one for unrecognized words, and one to split up the tags. In
scala you can do this pretty easily like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1: Recognize a fully analyzed word so that they can be tokenized.  In the</span>
<span class="c1">// above test case, "cats," will not be separated by white space so we require</span>
<span class="c1">// this more complicated splitting method.</span>
<span class="k">val</span> <span class="nv">parseRegex</span> <span class="k">=</span> <span class="s">"""\^.*?\$"""</span><span class="o">.</span><span class="py">r</span>
<span class="c1">// 2: Recognize a word with morphological tags.</span>
<span class="k">val</span> <span class="nv">morphredRegex</span> <span class="k">=</span> <span class="s">"""\^(.+?)/(.+?)(&lt;[0-9a-z&lt;&gt;]+&gt;).*\$"""</span>
<span class="c1">// 3: Recognize a word that could not be recognized.  The transducer prepends</span>
<span class="c1">// &amp;quot;*&amp;quot; to unrecognized tokens, so we match and eliminate it.</span>
<span class="k">val</span> <span class="nv">unknownRegex</span> <span class="k">=</span> <span class="s">"""\^(.+)/\*(.+?)\$"""</span>
<span class="c1">// 4: A regular expression for matching morphological tags.  This is simpler</span>
<span class="c1">// than writing a splitting rule.</span>
<span class="k">val</span> <span class="nv">featureRegex</span> <span class="k">=</span> <span class="s">"""&lt;.*?&gt;"""</span>
</code></pre></div></div>

<p>Then all you need to do is run through the analyzed sentence and split it up
into separate tokens, some for root words and some for morphed features. You
can do that like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">tokens</span> <span class="k">=</span> <span class="nv">parseRegex</span><span class="o">.</span><span class="py">findAllIn</span><span class="o">(</span><span class="nv">out</span><span class="o">.</span><span class="py">toString</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">parseMatch</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span>
<span class="c1">// Match the current analyzed word as being morphed or unknown.  For morphed</span>
<span class="c1">// words, create a list of the lemma and the tags.  For unknown words just</span>
<span class="c1">// create a list of the lemma.</span>
<span class="nv">parseMatch</span><span class="o">.</span><span class="py">toString</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nf">morphredRegex</span><span class="o">(</span><span class="n">surface</span><span class="o">,</span> <span class="n">lemma</span><span class="o">,</span> <span class="n">tags</span><span class="o">)</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span>
        <span class="n">lemma</span> <span class="o">::</span> <span class="nv">featureRegex</span><span class="o">.</span><span class="py">findAllIn</span><span class="o">(</span><span class="n">tags</span><span class="o">).</span><span class="py">toList</span>
    <span class="k">case</span> <span class="nf">unknownRegex</span><span class="o">(</span><span class="n">surface</span><span class="o">,</span> <span class="n">lemma</span><span class="o">)</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">(</span><span class="n">lemma</span><span class="o">)</span>
<span class="o">}).</span><span class="py">reduceLeft</span><span class="o">(</span><span class="k">_</span><span class="o">++</span><span class="k">_</span><span class="o">).</span><span class="py">filter</span><span class="o">(!</span><span class="nv">rejectFeatures</span><span class="o">.</span><span class="py">contains</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
</code></pre></div></div>

<p>This bit of code’s pretty sweet. You first iterate over each analyzed word with
the first matcher. Then you match each word with the two word level regular
expressions: one for fully analyzed words and one for unrecognized words. After
that it’s easy smeesy, you just split the tags up with the last regular
expression and turn it all into a list. The last two bits at the end turn the
whole thing into a single list and lets you filter out tags or tokens you don’t
want.</p>

<p>So with that, you can now do simple and fast morphological analysis in Java,
Scala, or even Clojure (but who’d do something silly like that?)!-</p>

  </article>

  

</div>

    </div>

    <!-- Footer -->

    
<footer class="fixed-bottom">
  <div class="container mt-0">
    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
      <img alt="Creative Commons License"
           style="border-width:0"
           src="https://i.creativecommons.org/l/by/4.0/88x31.png" />
    </a>
    This
    work is licensed under a
    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
      Creative Commons Attribution 4.0 International License
    </a>.

    <br />

    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with the <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>.

  </div>
</footer>



  </body>

  <!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>

  
<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>


  


<!-- Medium Zoom JS -->
<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/assets/js/zoom.js"></script>


<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
